<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: controllers/usuario.controller.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: controllers/usuario.controller.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Importación de los servicios necesarios
const UsuarioService          = require('../services/usuario.service');
const EspecialistaService     = require('../services/especialista.service');
const TokenService            = require('../services/token.service');
const EmailService            = require('../services/email.service');

// Importación de las librerías necesarias
const bcrypt                  = require('bcryptjs');
const jwt                     = require('jsonwebtoken');

// Importación de los helpers necesarios
const createAccessToken       = require('../helpers/jwt/createAccessToken');
const createResetToken        = require('../helpers/jwt/createResetToken');
const createRefreshToken      = require('../helpers/jwt/createRefreshToken');
const createEncryptedPassword = require('../util/functions/createEncryptedPassword');
const createUserObject        = require('../util/functions/createUserObject');
const createHistClinica       = require('../util/functions/createHistClinica');
const verifyResetToken        = require('../helpers/jwt/verifyResetToken');

// Importación de las funciones necesarias
const getSearchValuesByRole   = require("../util/functions/getSearchValuesByRole");


/**
 * @class UsuarioController
 * @description Clase estática que implementa la lógica de los usuarios de la aplicación.
 */
class UsuarioController {
  /**
   * @name getUsuario
   * @description Método asíncrono que obtiene un usuario de la base de datos.
   *              Devuelve un objeto JSON con la respuesta HTTP que incluye los datos del usuario.
   *              Si el usuario no existe, devuelve un error con el mensaje correspondiente.
   * @static
   * @async
   * @function
   * @param {Object} req - El objeto de solicitud de Express.
   * @param {Object} res - El objeto de respuesta de Express.
   * @returns {Object} res - El objeto de respuesta de Express.
   * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
   * @memberof UsuarioController
   */
  static async getUsuario(req, res) {
    let id = 0;
    let role_id = 0;

    if (req.user_role === 2) {
      id = req.user_id;
      role_id = 2;
    } else if (req.user_role === 1) {
      id = req.params.usuario_id;
    }

    try {
      if (!role_id) {
        role_id = await UsuarioService.readUsuarioRoleById(id);

        if (!role_id) {
          return res.status(404).json({
            errors: ['Usuario no encontrado.']
          });
        }
      }

      if (role_id === 2) {
        const user = await UsuarioService.readUsuarioPaciente(id);

        if (!user) {
          return res.status(404).json({
            errors: ['Usuario no encontrado.']
          });
        }

        return res.status(200).json(user);
      }

      const user = await UsuarioService.readUsuarioEspecialista(id);

      if (!user) {
        return res.status(404).json({
          errors: ['Usuario no encontrado.']
        });
      }

      return res.status(200).json(user);
    } catch (err) {
      return res.status(500).json({errors: [err.message]});
    }
  }

  /**
   * @name getListado
   * @description Método asíncrono que obtiene una lista de usuarios de la base de datos.
   *              Devuelve un objeto JSON con la respuesta HTTP que incluye los datos de los usuarios y la información de paginación.
   *              Si la página solicitada no existe, devuelve un error con el mensaje correspondiente.
   * @static
   * @async
   * @function
   * @param {Object} req - El objeto de solicitud de Express.
   * @param {Object} res - El objeto de respuesta de Express.
   * @returns {Object} res - El objeto de respuesta de Express.
   * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
   * @memberof UsuarioController
   */
  static async getListado(req, res) {
    const limit = 10;

    try {
      const searchValues = getSearchValuesByRole(req);

      const page = searchValues.page;
      const role_id = searchValues.role;

      const {
        rows: resultados,
        actualPage: pagina_actual,
        total: cantidad_usuarios,
        totalPages: paginas_totales
      } =
        await UsuarioService.readAllUsuarios(searchValues, limit);

      if (page > 1 &amp;&amp; page > paginas_totales) {
        return res.status(404).json({
          errors: ['La página de usuarios solicitada no existe.']
        });
      }

      const prev = page > 1
        ? role_id
          ? `/usuario/listado?page=${page - 1}&amp;role=${role_id}`
          : `/usuario/listado?page=${page - 1}`
        : null;
      const next = page &lt; paginas_totales
        ? role_id
          ? `/usuario/listado?page=${page + 1}&amp;role=${role_id}`
          : `/usuario/listado?page=${page + 1}`
        : null;
      const result_min = (page - 1) * limit + 1;
      const result_max = resultados.length === limit ? page * limit : (page - 1) * limit + resultados.length;
      const items_pagina = limit;

      const users = {
        prev,
        next,
        pagina_actual,
        paginas_totales,
        cantidad_usuarios,
        items_pagina,
        result_min,
        result_max,
        resultados
      }

      return res.status(200).json(users);
    } catch (err) {
      return res.status(500).json({errors: [err.message]});
    }
  }

  /**
   * @name postRegistro
   * @description Método asíncrono que registra un nuevo usuario en la base de datos.
   *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
   *              Si el correo electrónico o el DNI ya están en uso, devuelve un error con el mensaje correspondiente.
   * @static
   * @async
   * @function
   * @param {Object} req - El objeto de solicitud de Express.
   * @param {Object} res - El objeto de respuesta de Express.
   * @returns {Object} res - El objeto de respuesta de Express.
   * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
   * @memberof UsuarioController
   */
  static async postRegistro(req, res) {
    try {
      const errors = [];

      const emailExists = await UsuarioService.readUsuarioByEmail(req.body.email);
      if (emailExists) {
        errors.push('El correo ya está en uso.');
      }

      const dniExists = await UsuarioService.readUsuarioByDNI(req.body.dni);
      if (dniExists) {
        errors.push('El DNI ya está en uso.');
      }

      if (errors.length > 0) {
        return res.status(409).json({errors: errors});
      }

      const encryptedPassword = await createEncryptedPassword(req.body.password);
      const user = createUserObject(req, encryptedPassword, 2);

      const patient = {
        num_hist_clinica: await createHistClinica(),
        fecha_nacimiento: req.body.fecha_nacimiento,
        tipo_via: req.body.tipo_via,
        nombre_via: req.body.nombre_via,
        numero: req.body.numero,
        piso: req.body.piso,
        puerta: req.body.puerta,
        municipio: req.body.municipio,
        codigo_postal: req.body.codigo_postal,
        tel_fijo: req.body.tel_fijo,
        tel_movil: req.body.tel_movil
      }

      await UsuarioService.createUsuarioPaciente(user, patient);

      await EmailService.sendWelcomeEmail(req.body.email, req.body.nombre);

      return res.status(200).json({message: 'Usuario creado exitosamente.'});
    } catch (err) {
      return res.status(500).json({errors: [err.message]});
    }
  }

  /**
   * @name postRegistroEspecialista
   * @description Método asíncrono que registra un nuevo especialista en la base de datos.
   *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
   *              Si el correo electrónico ya está en uso, devuelve un error con el mensaje correspondiente.
   * @static
   * @async
   * @function
   * @param {Object} req - El objeto de solicitud de Express.
   * @param {Object} res - El objeto de respuesta de Express.
   * @returns {Object} res - El objeto de respuesta de Express.
   * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
   * @memberof UsuarioController
   */
  static async postRegistroEspecialista(req, res) {
    try {
      const userExists = await UsuarioService.readUsuarioByEmail(req.body.email);

      if (userExists) {
        return res.status(409).json({
          errors: ['El correo ya está en uso.']
        });
      }

      const encryptedPassword = await createEncryptedPassword(req.body.password);
      const user = createUserObject(req, encryptedPassword, 3);

      let descripcion = req.body.descripcion;
      descripcion = descripcion.replace(/(\r\n|\n|\r)/g, '&lt;br>');

      const specialist = {
        num_colegiado: req.body.num_colegiado,
        descripcion: descripcion,
        imagen: req.body.imagen,
        turno: req.body.turno,
        especialidad_id: req.body.especialidad_id,
        consulta_id: req.body.consulta_id
      }

      await UsuarioService.createUsuarioEspecialista(user, specialist);

      return res.status(200).json({message: 'Usuario creado exitosamente.'});
    } catch (err) {
      return res.status(500).json({errors: [err.message]});
    }
  }

  /**
   * @name postLogin
   * @description Método asíncrono que maneja el inicio de sesión de un usuario.
   *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito y los tokens de acceso y actualización.
   *              Si el correo electrónico o la contraseña son incorrectos, devuelve un error con el mensaje correspondiente.
   * @static
   * @async
   * @function
   * @param {Object} req - El objeto de solicitud de Express.
   * @param {Object} res - El objeto de respuesta de Express.
   * @returns {Object} res - El objeto de respuesta de Express.
   * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
   * @memberof UsuarioController
   */
  static async postLogin(req, res) {
    const email = req.body.email;
    const password = req.body.password;

    try {
      const user = await UsuarioService.readUsuarioByEmail(email);

      if (!user) {
        return res.status(403).json({
          errors: ['Correo o contraseña incorrectos.']
        });
      }

      const validPassword = await bcrypt.compare(password, user.password);

      if (!validPassword) {
        return res.status(403).json({
          errors: ['Correo o contraseña incorrectos.']
        });
      }

      const accessToken = createAccessToken(user);
      const refreshToken = createRefreshToken(user);

      await UsuarioService.updateRefreshToken(user.id, refreshToken);

      return res.status(200).json({
        message: 'Inicio de sesión exitoso.',
        access_token: accessToken,
        refresh_token: refreshToken
      });
    } catch (err) {
      return res.status(500).json({errors: [err.message]});
    }
  }

  /**
   * @name postForgotPassword
   * @description Método asíncrono que maneja la solicitud de restablecimiento de contraseña de un usuario.
   *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
   *              Si el correo electrónico no se encuentra en la base de datos, devuelve un error con el mensaje correspondiente.
   * @static
   * @async
   * @function
   * @param {Object} req - El objeto de solicitud de Express.
   * @param {Object} res - El objeto de respuesta de Express.
   * @returns {Object} res - El objeto de respuesta de Express.
   * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
   * @memberof UsuarioController
   */
  static async postForgotPassword(req, res) {
    const email = req.body.email;

    try {
      const user = await UsuarioService.readUsuarioByEmail(email);
      if (!user) {
        return res.status(404).json({
          errors: ['Correo no encontrado en la base de datos.']
        });
      }

      const idUser = user.id;
      const resetToken = createResetToken(user);

      await TokenService.createToken(idUser, resetToken);

      await EmailService.sendPasswordResetEmail(email, user, resetToken);

      return res.status(200).json({
        message: 'Correo enviado exitosamente.'
      });

    } catch (err) {
      return res.status(500).json({errors: [err.message]});
    }
  }

  /**
   * @name postResetPassword
   * @description Método asíncrono que maneja el restablecimiento de la contraseña de un usuario.
   *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
   *              Si el token es inválido o ha expirado, o si el usuario no se encuentra, devuelve un error con el mensaje correspondiente.
   * @static
   * @async
   * @function
   * @param {Object} req - El objeto de solicitud de Express.
   * @param {Object} res - El objeto de respuesta de Express.
   * @returns {Object} res - El objeto de respuesta de Express.
   * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
   * @memberof UsuarioController
   */
  static async postResetPassword(req, res) {
    const newPassword = req.body.password;

    const userEmail = await verifyResetToken(req, res);

    try {
      const user = await UsuarioService.readUsuarioByEmail(userEmail);

      if (!user) {
        return res.status(404).json({
          errors: ['Usuario no encontrado.']
        });
      }

      const encryptedPassword = await createEncryptedPassword(newPassword);
      await UsuarioService.updatePassword(user.email, encryptedPassword);

      return res.status(200).json({
        message: 'Contraseña actualizada exitosamente.'
      });
    } catch (err) {
      return res.status(500).json({errors: [err.message]});
    }
  }


  /**
   * @name postUpdatePassword
   * @description Método asíncrono que actualiza la contraseña de un usuario en la base de datos.
   *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
   *              Si el correo electrónico no se encuentra en la base de datos, o si el usuario no tiene permiso para realizar la acción,
   *              devuelve un error con el mensaje correspondiente.
   * @static
   * @async
   * @function
   * @param {Object} req - El objeto de solicitud de Express.
   * @param {Object} res - El objeto de respuesta de Express.
   * @returns {Object} res - El objeto de respuesta de Express.
   * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
   * @memberof UsuarioController
   */
  static async postUpdatePassword(req, res) {
    const email = req.body.email;
    const password = req.body.password;

    const id = req.user_id;

    try {
      const user = await UsuarioService.readUsuarioByEmail(email);

      if (!user) {
        return res.status(404).json({
          errors: ['Correo no encontrado.']
        });
      }

      if (user.id !== id) {
        return res.status(403).json({
          errors: ['No tienes permiso para realizar esta acción.']
        });
      }

      const encryptedPassword = await createEncryptedPassword(password);

      await UsuarioService.updatePassword(email, encryptedPassword);

      return res.status(200).json({
        message: 'Contraseña actualizada exitosamente.'
      });
    } catch (err) {
      return res.status(500).json({
        errors: [err.message]
      });
    }
  }

  /**
   * @name deleteUsuario
   * @description Método asíncrono que elimina un usuario de la base de datos utilizando su ID.
   *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
   *              Si el usuario no existe, devuelve un error con el mensaje correspondiente.
   * @static
   * @async
   * @function
   * @param {Object} req - El objeto de solicitud de Express.
   * @param {Object} res - El objeto de respuesta de Express.
   * @returns {Object} res - El objeto de respuesta de Express.
   * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
   * @memberof UsuarioController
   */
  static async deleteUsuario(req, res) {
    const id = req.user_id;

    try {
      await UsuarioService.deleteUsuario(id);

      return res.status(200).json({
        message: 'Usuario eliminado exitosamente.'
      });
    } catch (err) {
      return res.status(500).json({
        errors: [err.message]
      });
    }
  }

  /**
   * @name postRefreshToken
   * @description Método asíncrono que maneja la renovación del token de acceso de un usuario.
   *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito y los nuevos tokens de acceso y actualización.
   *              Si el token de actualización no se proporciona, es inválido, o el usuario no se encuentra, devuelve un error con el mensaje correspondiente.
   * @static
   * @async
   * @function
   * @param {Object} req - El objeto de solicitud de Express.
   * @param {Object} res - El objeto de respuesta de Express.
   * @returns {Object} res - El objeto de respuesta de Express.
   * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 403 con un mensaje de error.
   * @memberof UsuarioController
   */
  static async postRefreshToken(req, res) {
    const refreshToken = req.body.refresh_token;

    if (!refreshToken) {
      console.log('No se proporcionó el token de actualización.')
      return res.status(403).json({
        errors: ['No se proporcionó el token de actualización.']
      });
    }

    try {
      const decodedToken = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET_KEY);

      const user = await UsuarioService.readUsuarioById(decodedToken.user_id);
      if (!user) {
        return res.status(404).json({
          errors: ['Usuario no encontrado.']
        });
      }

      if (user.refresh_token !== refreshToken) {
        return res.status(403).json({
          errors: ['Token de actualización inválido.']
        });
      }

      const newAccessToken = createAccessToken(user);
      const newRefreshToken = createRefreshToken(user);

      await UsuarioService.updateRefreshToken(user.id, newRefreshToken);

      return res.status(200).json({
        message: 'Token de acceso renovado exitosamente.',
        access_token: newAccessToken,
        refresh_token: newRefreshToken
      });
    } catch (err) {
      return res.status(403).json({
        errors: ['Token de actualización inválido.']
      });
    }
  }

  /**
   * @name postLogout
   * @description Método asíncrono que maneja el cierre de sesión de un usuario.
   *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
   *              Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
   * @static
   * @async
   * @function
   * @param {Object} req - El objeto de solicitud de Express.
   * @param {Object} res - El objeto de respuesta de Express.
   * @returns {Object} res - El objeto de respuesta de Express.
   * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
   * @memberof UsuarioController
   */
  static async postLogout(req, res) {
    const userId = req.user_id;

    try {
      await UsuarioService.updateRefreshToken(userId, null);

      return res.status(200).json({message: 'Cierre de sesión correcto.'});
    } catch (err) {
      return res.status(500).json({errors: [err.message]});
    }
  }

  /**
   * @name putUsuarioPaciente
   * @description Método asíncrono que actualiza los datos de un usuario paciente en la base de datos.
   *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
   *              Si el DNI ya está en uso por otro usuario, devuelve un error con el mensaje correspondiente.
   *              Si el usuario no existe o no tiene permiso para realizar la acción, devuelve un error con el mensaje correspondiente.
   * @static
   * @async
   * @function
   * @param {Object} req - El objeto de solicitud de Express.
   * @param {Object} res - El objeto de respuesta de Express.
   * @returns {Object} res - El objeto de respuesta de Express.
   * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
   * @memberof UsuarioController
   */
  static async putUsuarioPaciente(req, res) {
    let usuario_id = 0;

    if (req.user_role === 2) {
      usuario_id = req.user_id;
    } else if (req.user_role === 1) {
      usuario_id = req.params.usuario_id;
    }

    try {
      const user = await UsuarioService.readUsuarioById(usuario_id);

      if (!user) {
        return res.status(404).json(
          {errors: ['Usuario no encontrado.']
          });
      }

      const dniExits = await UsuarioService.readUsuarioByDNI(req.body.dni);

      if (dniExits &amp;&amp; user.dni !== req.body.dni) {
        return res.status(409).json({
          errors: ['El DNI ya está en uso.']
        });
      }

      const emailExists = await UsuarioService.readUsuarioByEmail(req.body.email);

      if (emailExists &amp;&amp; user.email !== req.body.email) {
        return res.status(409).json({
          errors: ['El correo ya está en uso.']
        });
      }

      const userUpdate = {
        email: req.body.email,
        nombre: req.body.nombre,
        primer_apellido: req.body.primer_apellido,
        segundo_apellido: req.body.segundo_apellido,
        dni: req.body.dni
      }

      const patientUpdate = {
        fecha_nacimiento: req.body.fecha_nacimiento,
        tipo_via: req.body.tipo_via,
        nombre_via: req.body.nombre_via,
        numero: req.body.numero,
        piso: req.body.piso,
        puerta: req.body.puerta,
        municipio: req.body.municipio,
        codigo_postal: req.body.codigo_postal,
        tel_fijo: req.body.tel_fijo,
        tel_movil: req.body.tel_movil
      }

      await UsuarioService.updateUsuarioPaciente(userUpdate, patientUpdate);

      return res.status(200).json({message: 'Usuario actualizado exitosamente.'});
    } catch (err) {
      return res.status(500).json({errors: [err.message]});
    }
  }

  /**
   * @name putUsuarioEspecialista
   * @description Método asíncrono que actualiza los datos de un usuario especialista en la base de datos.
   *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
   *              Si el usuario no existe o no tiene permiso para realizar la acción, devuelve un error con el mensaje correspondiente.
   * @static
   * @async
   * @function
   * @param {Object} req - El objeto de solicitud de Express.
   * @param {Object} res - El objeto de respuesta de Express.
   * @returns {Object} res - El objeto de respuesta de Express.
   * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
   * @memberof UsuarioController
   */
  static async putUsuarioEspecialista(req, res) {
    const id = req.params.usuario_id;

    try {
      const user = await UsuarioService.readUsuarioById(id);

      if (!user) {
        return res.status(404).json(
          {errors: ['Usuario no encontrado.']
          });
      }

      const dniExits = await UsuarioService.readUsuarioByDNI(req.body.dni);

      if (dniExits &amp;&amp; user.dni !== req.body.dni) {
        return res.status(409).json({
          errors: ['El DNI ya está en uso.']
        });
      }

      const numColegiadoExists = await EspecialistaService.readEspecialistaByNumColegiado(req.body.num_colegiado);

      if (numColegiadoExists &amp;&amp; user.num_colegiado !== req.body.num_colegiado) {
        return res.status(409).json({
          errors: ['El número de colegiado ya está en uso.']
        });
      }

      const emailExists = await UsuarioService.readUsuarioByEmail(req.body.email);

      if (emailExists &amp;&amp; user.email !== req.body.email) {
        return res.status(409).json({
          errors: ['El correo ya está en uso.']
        });
      }

      const specialist = {
        email: req.body.email,
        nombre: req.body.nombre,
        primer_apellido: req.body.primer_apellido,
        segundo_apellido: req.body.segundo_apellido,
        dni: req.body.dni,
        num_colegiado: req.body.num_colegiado,
        descripcion: req.body.descripcion,
        turno: req.body.turno,
        especialidad_id: req.body.especialidad_id,
        consulta_id: req.body.consulta_id,
        imagen: req.body.imagen
      }

      await UsuarioService.updateUsuarioEspecialista(user, specialist);

      return res.status(200).json({message: 'Usuario actualizado exitosamente.'});
    } catch (err) {
      return res.status(500).json({errors: [err.message]});
    }
  }
}

// Exportación del controlador
module.exports = UsuarioController;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="Helpers-JWT.html">Helpers-JWT</a></li><li><a href="Helpers-Validators-Body.html">Helpers-Validators-Body</a></li><li><a href="Helpers-Validators-Params.html">Helpers-Validators-Params</a></li><li><a href="Helpers-Validators-QueryParams.html">Helpers-Validators-QueryParams</a></li><li><a href="Util-Database.html">Util-Database</a></li><li><a href="Util-Functions.html">Util-Functions</a></li><li><a href="Util-Middleware.html">Util-Middleware</a></li></ul><h3>Classes</h3><ul><li><a href="CitaController.html">CitaController</a></li><li><a href="CitaModel.html">CitaModel</a></li><li><a href="CitaService.html">CitaService</a></li><li><a href="CodigoPostalMunicipioController.html">CodigoPostalMunicipioController</a></li><li><a href="CodigoPostalMunicipioModel.html">CodigoPostalMunicipioModel</a></li><li><a href="CodigoPostalMunicipioService.html">CodigoPostalMunicipioService</a></li><li><a href="ConsultaController.html">ConsultaController</a></li><li><a href="ConsultaModel.html">ConsultaModel</a></li><li><a href="ConsultaService.html">ConsultaService</a></li><li><a href="ContactoController.html">ContactoController</a></li><li><a href="EmailService.html">EmailService</a></li><li><a href="EspecialidadController.html">EspecialidadController</a></li><li><a href="EspecialidadModel.html">EspecialidadModel</a></li><li><a href="EspecialidadService.html">EspecialidadService</a></li><li><a href="EspecialistaController.html">EspecialistaController</a></li><li><a href="EspecialistaModel.html">EspecialistaModel</a></li><li><a href="EspecialistaService.html">EspecialistaService</a></li><li><a href="GlucometriaController.html">GlucometriaController</a></li><li><a href="GlucometriaModel.html">GlucometriaModel</a></li><li><a href="GlucometriaService.html">GlucometriaService</a></li><li><a href="InformeController.html">InformeController</a></li><li><a href="InformeModel.html">InformeModel</a></li><li><a href="InformePatologiaModel.html">InformePatologiaModel</a></li><li><a href="InformePatologiaService.html">InformePatologiaService</a></li><li><a href="InformeService.html">InformeService</a></li><li><a href="MedicamentoController.html">MedicamentoController</a></li><li><a href="MedicamentoModel.html">MedicamentoModel</a></li><li><a href="MedicamentoService.html">MedicamentoService</a></li><li><a href="MunicipioController.html">MunicipioController</a></li><li><a href="MunicipioModel.html">MunicipioModel</a></li><li><a href="MunicipioService.html">MunicipioService</a></li><li><a href="PacienteController.html">PacienteController</a></li><li><a href="PacienteModel.html">PacienteModel</a></li><li><a href="PacienteService.html">PacienteService</a></li><li><a href="PacienteTomaMedicamentoController.html">PacienteTomaMedicamentoController</a></li><li><a href="PacienteTomaMedicamentoModel.html">PacienteTomaMedicamentoModel</a></li><li><a href="PacienteTomaMedicamentoService.html">PacienteTomaMedicamentoService</a></li><li><a href="PatologiaController.html">PatologiaController</a></li><li><a href="PatologiaModel.html">PatologiaModel</a></li><li><a href="PatologiaService.html">PatologiaService</a></li><li><a href="PdfService.html">PdfService</a></li><li><a href="ProvinciaController.html">ProvinciaController</a></li><li><a href="ProvinciaModel.html">ProvinciaModel</a></li><li><a href="ProvinciaService.html">ProvinciaService</a></li><li><a href="TensionArterialController.html">TensionArterialController</a></li><li><a href="TensionArterialModel.html">TensionArterialModel</a></li><li><a href="TensionArterialService.html">TensionArterialService</a></li><li><a href="TipoViaController.html">TipoViaController</a></li><li><a href="TipoViaModel.html">TipoViaModel</a></li><li><a href="TipoViaService.html">TipoViaService</a></li><li><a href="TokenModel.html">TokenModel</a></li><li><a href="TokenService.html">TokenService</a></li><li><a href="TomaModel.html">TomaModel</a></li><li><a href="TomaService.html">TomaService</a></li><li><a href="UsuarioController.html">UsuarioController</a></li><li><a href="UsuarioModel.html">UsuarioModel</a></li><li><a href="UsuarioService.html">UsuarioService</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Wed May 01 2024 19:26:37 GMT+0200 (hora de verano de Europa central)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
