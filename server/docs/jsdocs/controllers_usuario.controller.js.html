<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: controllers/usuario.controller.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: controllers/usuario.controller.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Importación de los servicios necesarios
const UsuarioService          = require('../services/usuario.service');
const EspecialistaService     = require('../services/especialista.service');
const TokenService            = require('../services/token.service');
const EmailService            = require('../services/email.service');

// Importación de las librerías necesarias
const bcrypt                  = require('bcryptjs');
const jwt                     = require('jsonwebtoken');

// Importación de los helpers necesarios
const createAccessToken       = require('../helpers/jwt/createAccessToken');
const createResetToken        = require('../helpers/jwt/createResetToken');
const createRefreshToken      = require('../helpers/jwt/createRefreshToken');
const createEncryptedPassword = require('../util/functions/createEncryptedPassword');
const createUserObject        = require('../util/functions/createUserObject');
const createHistClinica       = require('../util/functions/createHistClinica');

// Importación de las funciones necesarias
const getSearchValuesByRole   = require("../util/functions/getSearchValuesByRole");

/**
 * @name getUsuario
 * @description Método asíncrono que obtiene un usuario de la base de datos.
 *              Devuelve un objeto JSON con la respuesta HTTP que incluye los datos del usuario.
 *              Si el usuario no existe, devuelve un error con el mensaje correspondiente.
 * @async
 * @function
 * @param {Object} req - El objeto de solicitud de Express.
 * @param {Object} res - El objeto de respuesta de Express.
 * @returns {Object} res - El objeto de respuesta de Express.
 * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
 * @memberof Controllers-Usuario
 */
exports.getUsuario = async (req, res) => {
  let id = 0;
  let role_id = 0;

  if (req.user_role === 2) {
    id = req.user_id;
    role_id = 2;
  } else if (req.user_role === 1) {
    id = req.params.usuario_id;
  }

  try {
    if (!role_id) {
      role_id = await UsuarioService.readUsuarioRoleById(id);

      if (!role_id) {
        return res.status(404).json({
          errors: ['Usuario no encontrado.']
        });
      }
    }

    if (role_id === 2) {
      const user = await UsuarioService.readUsuarioPaciente(id);

      if (!user) {
        return res.status(404).json({
          errors: ['Usuario no encontrado.']
        });
      }

      return res.status(200).json(user);
    }

    const user = await UsuarioService.readUsuarioEspecialista(id);

    if (!user) {
      return res.status(404).json({
        errors: ['Usuario no encontrado.']
      });
    }

    return res.status(200).json(user);
  } catch (err) {
    return res.status(500).json({errors: [err.message]});
  }
}

/**
 * @name getListado
 * @description Método asíncrono que obtiene una lista de usuarios de la base de datos.
 *              Devuelve un objeto JSON con la respuesta HTTP que incluye los datos de los usuarios y la información de paginación.
 *              Si la página solicitada no existe, devuelve un error con el mensaje correspondiente.
 * @async
 * @function
 * @param {Object} req - El objeto de solicitud de Express.
 * @param {Object} res - El objeto de respuesta de Express.
 * @returns {Object} res - El objeto de respuesta de Express.
 * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
 * @memberof Controllers-Usuario
 */
exports.getListado = async (req, res) => {
  const limit = 10;

  try {
    const searchValues = getSearchValuesByRole(req);

    const page = searchValues.page;
    const role_id = searchValues.role;

    const {
      rows: resultados,
      actualPage: pagina_actual,
      total: cantidad_usuarios,
      totalPages: paginas_totales
    } =
      await UsuarioService.readAllUsuarios(searchValues, limit);

    if (page > 1 &amp;&amp; page > paginas_totales) {
      return res.status(404).json({
        errors: ['La página de usuarios solicitada no existe.']
      });
    }

    const prev = page > 1
      ? role_id
        ? `/usuario/listado?page=${page - 1}&amp;role=${role_id}`
        : `/usuario/listado?page=${page - 1}`
      : null;
    const next = page &lt; paginas_totales
      ? role_id
        ? `/usuario/listado?page=${page + 1}&amp;role=${role_id}`
        : `/usuario/listado?page=${page + 1}`
      : null;
    const result_min = (page - 1) * limit + 1;
    const result_max = resultados.length === limit ? page * limit : (page - 1) * limit + resultados.length;
    const items_pagina = limit;

    const users = {
      prev,
      next,
      pagina_actual,
      paginas_totales,
      cantidad_usuarios,
      items_pagina,
      result_min,
      result_max,
      resultados
    }

    return res.status(200).json(users);
  } catch (err) {
    return res.status(500).json({errors: [err.message]});
  }
}

/**
 * @name postRegistro
 * @description Método asíncrono que registra un nuevo usuario en la base de datos.
 *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
 *              Si el correo electrónico o el DNI ya están en uso, devuelve un error con el mensaje correspondiente.
 * @async
 * @function
 * @param {Object} req - El objeto de solicitud de Express.
 * @param {Object} res - El objeto de respuesta de Express.
 * @returns {Object} res - El objeto de respuesta de Express.
 * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
 * @memberof Controllers-Usuario
 */
exports.postRegistro = async (req, res) => {
  try {
    const errors = [];

    const emailExists = await UsuarioService.readUsuarioByEmail(req.body.email);
    if (emailExists) {
      errors.push('El correo ya está en uso.');
    }

    const dniExists = await UsuarioService.readUsuarioByDNI(req.body.dni);
    if (dniExists) {
      errors.push('El DNI ya está en uso.');
    }

    if (errors.length > 0) {
      return res.status(409).json({errors: errors});
    }

    const encryptedPassword = await createEncryptedPassword(req.body.password);
    const user = createUserObject(req, encryptedPassword, 2);

    const patient = {
      num_hist_clinica: await createHistClinica(),
      fecha_nacimiento: req.body.fecha_nacimiento,
      tipo_via: req.body.tipo_via,
      nombre_via: req.body.nombre_via,
      numero: req.body.numero,
      piso: req.body.piso,
      puerta: req.body.puerta,
      municipio: req.body.municipio,
      codigo_postal: req.body.codigo_postal,
      tel_fijo: req.body.tel_fijo,
      tel_movil: req.body.tel_movil
    }

    await UsuarioService.createUsuarioPaciente(user, patient);

    await EmailService.sendWelcomeEmail(req.body.email, req.body.nombre);

    return res.status(200).json({message: 'Usuario creado exitosamente.'});
  } catch (err) {
    return res.status(500).json({errors: [err.message]});
  }
}

/**
 * @name postRegistroEspecialista
 * @description Método asíncrono que registra un nuevo especialista en la base de datos.
 *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
 *              Si el correo electrónico ya está en uso, devuelve un error con el mensaje correspondiente.
 * @async
 * @function
 * @param {Object} req - El objeto de solicitud de Express.
 * @param {Object} res - El objeto de respuesta de Express.
 * @returns {Object} res - El objeto de respuesta de Express.
 * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
 * @memberof Controllers-Usuario
 */
exports.postRegistroEspecialista = async (req, res) => {
  try {
    const userExists = await UsuarioService.readUsuarioByEmail(req.body.email);

    if (userExists) {
      return res.status(409).json({
        errors: ['El correo ya está en uso.']
      });
    }

    const encryptedPassword = await createEncryptedPassword(req.body.password);
    const user = createUserObject(req, encryptedPassword, 3);

    let descripcion = req.body.descripcion;
    descripcion = descripcion.replace(/(\r\n|\n|\r)/g, '&lt;br>');

    const specialist = {
      num_colegiado: req.body.num_colegiado,
      descripcion: descripcion,
      imagen: req.body.imagen,
      turno: req.body.turno,
      especialidad_id: req.body.especialidad_id,
      consulta_id: req.body.consulta_id
    }

    await UsuarioService.createUsuarioEspecialista(user, specialist);

    return res.status(200).json({message: 'Usuario creado exitosamente.'});
  } catch (err) {
    return res.status(500).json({errors: [err.message]});
  }
}

/**
 * @name postLogin
 * @description Método asíncrono que maneja el inicio de sesión de un usuario.
 *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito y los tokens de acceso y actualización.
 *              Si el correo electrónico o la contraseña son incorrectos, devuelve un error con el mensaje correspondiente.
 * @async
 * @function
 * @param {Object} req - El objeto de solicitud de Express.
 * @param {Object} res - El objeto de respuesta de Express.
 * @returns {Object} res - El objeto de respuesta de Express.
 * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
 * @memberof Controllers-Usuario
 */
exports.postLogin = async (req, res) => {
  const email = req.body.email;
  const password = req.body.password;

  try {
    const user = await UsuarioService.readUsuarioByEmail(email);

    if (!user) {
      return res.status(403).json({
        errors: ['Correo o contraseña incorrectos.']
      });
    }

    const validPassword = await bcrypt.compare(password, user.password);

    if (!validPassword) {
      return res.status(403).json({
        errors: ['Correo o contraseña incorrectos.']
      });
    }

    const accessToken = createAccessToken(user);
    const refreshToken = createRefreshToken(user);

    await UsuarioService.updateRefreshToken(user.id, refreshToken);

    return res.status(200).json({
      message: 'Inicio de sesión exitoso.',
      access_token: accessToken,
      refresh_token: refreshToken
    });
  } catch (err) {
    return res.status(500).json({errors: [err.message]});
  }
}

/**
 * @name postForgotPassword
 * @description Método asíncrono que maneja la solicitud de restablecimiento de contraseña de un usuario.
 *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
 *              Si el correo electrónico no se encuentra en la base de datos, devuelve un error con el mensaje correspondiente.
 * @async
 * @function
 * @param {Object} req - El objeto de solicitud de Express.
 * @param {Object} res - El objeto de respuesta de Express.
 * @returns {Object} res - El objeto de respuesta de Express.
 * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
 * @memberof Controllers-Usuario
 */
exports.postForgotPassword = async (req, res) => {
  const email = req.body.email;

  try {
    const user = await UsuarioService.readUsuarioByEmail(email);
    if (!user) {
      return res.status(404).json({
        errors: ['Correo no encontrado en la base de datos.']
      });
    }

    const idUser = user.id;
    const resetToken = createResetToken(user);

    await TokenService.createToken(idUser, resetToken);

    await EmailService.sendPasswordResetEmail(email, user, resetToken);

    return res.status(200).json({
      message: 'Correo enviado exitosamente.'
    });

  } catch (err) {
    return res.status(500).json({errors: [err.message]});
  }
}

/**
 * @name postResetPassword
 * @description Método asíncrono que maneja el restablecimiento de la contraseña de un usuario.
 *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
 *              Si el token es inválido o ha expirado, o si el usuario no se encuentra, devuelve un error con el mensaje correspondiente.
 * @async
 * @function
 * @param {Object} req - El objeto de solicitud de Express.
 * @param {Object} res - El objeto de respuesta de Express.
 * @returns {Object} res - El objeto de respuesta de Express.
 * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
 * @memberof Controllers-Usuario
 */
exports.postResetPassword = async (req, res) => {
  const resetToken = req.body.token;
  const newPassword = req.body.password;

  jwt.verify(resetToken, process.env.JWT_RESET_SECRET_KEY, async (err, decodedToken) => {
    if (err) {
      return res.status(403).json({
        errors: ['Token invalido o expirado.']
      });
    }

    try {
      const user = await UsuarioService.readUsuarioByEmail(decodedToken.email);

      if (!user) {
        return res.status(404).json({
          errors: ['Usuario no encontrado.']
        });
      }

      const encryptedPassword = await createEncryptedPassword(newPassword);
      await UsuarioService.updatePassword(user.email, encryptedPassword);

      return res.status(200).json({
        message: 'Contraseña actualizada exitosamente.'
      });
    } catch (err) {
      return res.status(500).json({errors: [err.message]});
    }
  });
}

/**
 * @name postUpdatePassword
 * @description Método asíncrono que actualiza la contraseña de un usuario en la base de datos.
 *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
 *              Si el correo electrónico no se encuentra en la base de datos, o si el usuario no tiene permiso para realizar la acción,
 *              devuelve un error con el mensaje correspondiente.
 * @async
 * @function
 * @param {Object} req - El objeto de solicitud de Express.
 * @param {Object} res - El objeto de respuesta de Express.
 * @returns {Object} res - El objeto de respuesta de Express.
 * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
 * @memberof Controllers-Usuario
 */
exports.postUpdatePassword = async (req, res) => {
  const email = req.body.email;
  const password = req.body.password;

  const id = req.user_id;

  try {
    const user = await UsuarioService.readUsuarioByEmail(email);

    if (!user) {
      return res.status(404).json({
        errors: ['Correo no encontrado.']
      });
    }

    if (user.id !== id) {
      return res.status(403).json({
        errors: ['No tienes permiso para realizar esta acción.']
      });
    }

    const encryptedPassword = await createEncryptedPassword(password);

    await UsuarioService.updatePassword(email, encryptedPassword);

    return res.status(200).json({
      message: 'Contraseña actualizada exitosamente.'
    });
  } catch (err) {
    return res.status(500).json({
      errors: [err.message]
    });
  }
}

/**
 * @name deleteUsuario
 * @description Método asíncrono que elimina un usuario de la base de datos utilizando su ID.
 *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
 *              Si el usuario no existe, devuelve un error con el mensaje correspondiente.
 * @async
 * @function
 * @param {Object} req - El objeto de solicitud de Express.
 * @param {Object} res - El objeto de respuesta de Express.
 * @returns {Object} res - El objeto de respuesta de Express.
 * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
 * @memberof Controllers-Usuario
 */
exports.deleteUsuario = async (req, res) => {
  const id = req.user_id;

  try {
    await UsuarioService.deleteUsuario(id);

    return res.status(200).json({
      message: 'Usuario eliminado exitosamente.'
    });
  } catch (err) {
    return res.status(500).json({
      errors: [err.message]
    });
  }
}

/**
 * @name postRefreshToken
 * @description Método asíncrono que maneja la renovación del token de acceso de un usuario.
 *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito y los nuevos tokens de acceso y actualización.
 *              Si el token de actualización no se proporciona, es inválido, o el usuario no se encuentra, devuelve un error con el mensaje correspondiente.
 * @async
 * @function
 * @param {Object} req - El objeto de solicitud de Express.
 * @param {Object} res - El objeto de respuesta de Express.
 * @returns {Object} res - El objeto de respuesta de Express.
 * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 403 con un mensaje de error.
 * @memberof Controllers-Usuario
 */
exports.postRefreshToken = async (req, res) => {
  const refreshToken = req.body.refresh_token;

  if (!refreshToken) {
    console.log('No se proporcionó el token de actualización.')
    return res.status(403).json({
      errors: ['No se proporcionó el token de actualización.']
    });
  }

  try {
    const decodedToken = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET_KEY);

    const user = await UsuarioService.readUsuarioById(decodedToken.user_id);
    if (!user) {
      return res.status(404).json({
        errors: ['Usuario no encontrado.']
      });
    }

    if (user.refresh_token !== refreshToken) {
      return res.status(403).json({
        errors: ['Token de actualización inválido.']
      });
    }

    const newAccessToken = createAccessToken(user);
    const newRefreshToken = createRefreshToken(user);

    await UsuarioService.updateRefreshToken(user.id, newRefreshToken);

    return res.status(200).json({
      message: 'Token de acceso renovado exitosamente.',
      access_token: newAccessToken,
      refresh_token: newRefreshToken
    });
  } catch (err) {
    return res.status(403).json({
      errors: ['Token de actualización inválido.']
    });
  }
}

/**
 * @name postLogout
 * @description Método asíncrono que maneja el cierre de sesión de un usuario.
 *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
 *              Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
 * @async
 * @function
 * @param {Object} req - El objeto de solicitud de Express.
 * @param {Object} res - El objeto de respuesta de Express.
 * @returns {Object} res - El objeto de respuesta de Express.
 * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
 * @memberof Controllers-Usuario
 */
exports.postLogout = async (req, res) => {
  const userId = req.user_id;

  try {
    await UsuarioService.updateRefreshToken(userId, null);

    return res.status(200).json({message: 'Cierre de sesión correcto.'});
  } catch (err) {
    return res.status(500).json({errors: [err.message]});
  }
}

/**
 * @name putUsuarioPaciente
 * @description Método asíncrono que actualiza los datos de un usuario paciente en la base de datos.
 *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
 *              Si el DNI ya está en uso por otro usuario, devuelve un error con el mensaje correspondiente.
 *              Si el usuario no existe o no tiene permiso para realizar la acción, devuelve un error con el mensaje correspondiente.
 * @async
 * @function
 * @param {Object} req - El objeto de solicitud de Express.
 * @param {Object} res - El objeto de respuesta de Express.
 * @returns {Object} res - El objeto de respuesta de Express.
 * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
 * @memberof Controllers-Usuario
 */
exports.putUsuarioPaciente = async (req, res) => {
  let usuario_id = 0;

  if (req.user_role === 2) {
    usuario_id = req.user_id;
  } else if (req.user_role === 1) {
    usuario_id = req.params.usuario_id;
  }

  try {
    const user = await UsuarioService.readUsuarioById(usuario_id);

    if (!user) {
      return res.status(404).json(
        {errors: ['Usuario no encontrado.']
        });
    }

    const dniExits = await UsuarioService.readUsuarioByDNI(req.body.dni);

    if (dniExits &amp;&amp; user.dni !== req.body.dni) {
      return res.status(409).json({
        errors: ['El DNI ya está en uso.']
      });
    }

    const emailExists = await UsuarioService.readUsuarioByEmail(req.body.email);

    if (emailExists &amp;&amp; user.email !== req.body.email) {
      return res.status(409).json({
        errors: ['El correo ya está en uso.']
      });
    }

    const userUpdate = {
      email: req.body.email,
      nombre: req.body.nombre,
      primer_apellido: req.body.primer_apellido,
      segundo_apellido: req.body.segundo_apellido,
      dni: req.body.dni
    }

    const patientUpdate = {
      fecha_nacimiento: req.body.fecha_nacimiento,
      tipo_via: req.body.tipo_via,
      nombre_via: req.body.nombre_via,
      numero: req.body.numero,
      piso: req.body.piso,
      puerta: req.body.puerta,
      municipio: req.body.municipio,
      codigo_postal: req.body.codigo_postal,
      tel_fijo: req.body.tel_fijo,
      tel_movil: req.body.tel_movil
    }

    await UsuarioService.updateUsuarioPaciente(userUpdate, patientUpdate);

    return res.status(200).json({message: 'Usuario actualizado exitosamente.'});
  } catch (err) {
    return res.status(500).json({errors: [err.message]});
  }
}

/**
 * @name putUsuarioEspecialista
 * @description Método asíncrono que actualiza los datos de un usuario especialista en la base de datos.
 *              Devuelve un objeto JSON con la respuesta HTTP que incluye un mensaje de éxito.
 *              Si el usuario no existe o no tiene permiso para realizar la acción, devuelve un error con el mensaje correspondiente.
 * @async
 * @function
 * @param {Object} req - El objeto de solicitud de Express.
 * @param {Object} res - El objeto de respuesta de Express.
 * @returns {Object} res - El objeto de respuesta de Express.
 * @throws {Error} Si ocurre algún error durante el proceso, captura el error y devuelve un error 500 con un mensaje de error.
 * @memberof Controllers-Usuario
 */
exports.putUsuarioEspecialista = async (req, res) => {
  const id = req.params.usuario_id;

  try {
    const user = await UsuarioService.readUsuarioById(id);

    if (!user) {
      return res.status(404).json(
        {errors: ['Usuario no encontrado.']
        });
    }

    const dniExits = await UsuarioService.readUsuarioByDNI(req.body.dni);

    if (dniExits &amp;&amp; user.dni !== req.body.dni) {
      return res.status(409).json({
        errors: ['El DNI ya está en uso.']
      });
    }

    const numColegiadoExists = await EspecialistaService.readEspecialistaByNumColegiado(req.body.num_colegiado);

    if (numColegiadoExists &amp;&amp; user.num_colegiado !== req.body.num_colegiado) {
      return res.status(409).json({
        errors: ['El número de colegiado ya está en uso.']
      });
    }

    const emailExists = await UsuarioService.readUsuarioByEmail(req.body.email);

    if (emailExists &amp;&amp; user.email !== req.body.email) {
      return res.status(409).json({
        errors: ['El correo ya está en uso.']
      });
    }

    const specialist = {
      email: req.body.email,
      nombre: req.body.nombre,
      primer_apellido: req.body.primer_apellido,
      segundo_apellido: req.body.segundo_apellido,
      dni: req.body.dni,
      num_colegiado: req.body.num_colegiado,
      descripcion: req.body.descripcion,
      turno: req.body.turno,
      especialidad_id: req.body.especialidad_id,
      consulta_id: req.body.consulta_id,
      imagen: req.body.imagen
    }

    await UsuarioService.updateUsuarioEspecialista(user, specialist);

    return res.status(200).json({message: 'Usuario actualizado exitosamente.'});
  } catch (err) {
    return res.status(500).json({errors: [err.message]});
  }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="Controllers-Cita.html">Controllers-Cita</a></li><li><a href="Controllers-CodigoPostalMunicipio.html">Controllers-CodigoPostalMunicipio</a></li><li><a href="Controllers-Consulta.html">Controllers-Consulta</a></li><li><a href="Controllers-Contacto.html">Controllers-Contacto</a></li><li><a href="Controllers-Especialidad.html">Controllers-Especialidad</a></li><li><a href="Controllers-Especialista.html">Controllers-Especialista</a></li><li><a href="Controllers-Glucometria.html">Controllers-Glucometria</a></li><li><a href="Controllers-Informe.html">Controllers-Informe</a></li><li><a href="Controllers-Medicamento.html">Controllers-Medicamento</a></li><li><a href="Controllers-Municipio.html">Controllers-Municipio</a></li><li><a href="Controllers-Paciente.html">Controllers-Paciente</a></li><li><a href="Controllers-PacienteTomaMedicamento.html">Controllers-PacienteTomaMedicamento</a></li><li><a href="Controllers-Patologia.html">Controllers-Patologia</a></li><li><a href="Controllers-Provincia.html">Controllers-Provincia</a></li><li><a href="Controllers-TensionArterial.html">Controllers-TensionArterial</a></li><li><a href="Controllers-TipoVia.html">Controllers-TipoVia</a></li><li><a href="Controllers-Usuario.html">Controllers-Usuario</a></li><li><a href="Helpers-JWT.html">Helpers-JWT</a></li><li><a href="Helpers-Validators-Body.html">Helpers-Validators-Body</a></li><li><a href="Helpers-Validators-Params.html">Helpers-Validators-Params</a></li><li><a href="Helpers-Validators-QueryParams.html">Helpers-Validators-QueryParams</a></li><li><a href="Util-Database.html">Util-Database</a></li><li><a href="Util-Functions.html">Util-Functions</a></li><li><a href="Util-Middleware.html">Util-Middleware</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Wed May 01 2024 12:45:18 GMT+0200 (hora de verano de Europa central)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
